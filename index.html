<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Atlas Frontend</title>

  <script src="https://unpkg.com/vue"></script>
  <script src="https://unpkg.com/vuex"></script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"
          integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
          crossorigin="anonymous"></script>
  <script
      src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <link
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
      media="all" rel="stylesheet"/>
  <link href="src/css/env-dropdown.css" media="all" rel="stylesheet"/>
  <link href="src/css/autocomplete.css" media="all" rel="stylesheet"/>
  <link href="src/css/style.css" media="all" rel="stylesheet"/>

  <link rel="import" href="src/partials/navbar.html">
  <link rel="import" href="src/partials/listing.html">
  <link rel="import" href="src/partials/row.html">
  <link rel="import" href="src/partials/confirm-button.html">
  <link rel="import" href="src/partials/autocomplete-input.html">
  <link rel="import" href="src/partials/commands.html">
</head>
<body>
<div id="atlas-navbar">
  <atlas-navbar
      :routes="routes"
      icons="sites"
      :environments="environments">
  </atlas-navbar>
</div>
<div class="page container">
  <message-area id="alert" :messages="messages" v-if="messages.length > 0"></message-area>
  <div id="site-listing" class="row">
    <transition name="slide-fade">
      <form id="statsSearch" class="row" v-if="showStatsSearch">
        <div class="form-group row">
          <div class="col-md-6">
            <label for="query-mongo">Query</label>
            <autocomplete-input
                id="query-mongo"
                :options-key="optionsKey"
                the-key="query"
                :model="statsQuery">
            </autocomplete-input>
          </div>
          <div class="col-md-6">
            <label for="query-name">Query Name</label>
            <autocomplete-input
                id="query-name"
                :options-key="optionsKey"
                the-key="title"
                :model="statsQueryName">
            </autocomplete-input>
          </div>
          <div v-if="userAccessPerm('statsSearch:save')">
            <div class="col-md-4">
              <label for="query-description">Query Description</label>
              <input type="text" name="query_description" id="query-description" class="form-control" v-model="statsQueryDescription">
            </div>
            <!-- Comment out until another endpoint other than stats is searched on this page.
            <div class="col-md-4">
              <label for="query-endpoint">Query Endpoint</label>
              <input type="text" name="query_endpoint" id="query-endpoint" class="form-control" v-model="statsQueryEndpoint">
            </div>
            -->
            <div class="col-md-4">
              <label for="query-tags">Query Tags</label>
              <input type="text" name="query_tags" id="query-tags" class="form-control" v-model="statsQueryTags">
            </div>
          </div>
        </div>
        <div class="form-group row col-md-6">
          <button class="btn btn-primary" @click.prevent="search()">Search</button>
          <button class="btn btn-primary" @click.prevent="saveSearch()" v-if="userAccessPerm('statsSearch:save')">Save To Atlas</button>
          <button class="btn btn-default" v-if="reset" @click.prevent="resetSearch()">Reset</button>
        </div>
      </form>
    </transition>
    <transition name="slide-fade">
      <commands
          :grid-columns="gridColumns"
          v-if="showCommands">
      </commands>
    </transition>
    <form id="search" class="row">
      <div class="form-group">
        <label for="filter-records">Filter Table</label>
        <input id="filter-records" class="form-control" name="query"
               v-model="searchQuery">
      </div>
    </form>
    <div class="row">
      <listing
          :data="gridData"
          :columns="gridColumns"
          :filter-key="searchQuery"
          :edit-keys="editKeys"
          :select-keys="selectKeys"
          :extra-content="rowViewContent"
          :callback="callback">
      </listing>
    </div>
    <div class="row" id="create-site" v-if="userAccessPerm('createSite')">
      <confirm-button
          label="Create A Site"
          callback="createSite">
      </confirm-button>
    </div>
  </div>
</div>
<script src="src/js/utilities.js"></script>
<script src="src/config/config.js"></script>
<script src="src/config/routes.js"></script>
<script src="src/js/components.js"></script>
<script src="src/js/navbar.js"></script>
<script src="src/js/export-table.js"></script>
<script src="src/js/site-records.js"></script>
<script src="src/js/code-records.js"></script>
<script type="text/javascript">
  /**
   * Creates the list of site records based on the environment. Every time the environment
   * changes via the environment selector, the search will update.
   */
  jQuery(document).ready(function () {
    siteListing.initialize();
  });

  /**
   * Imports component templates needed for this page.
   *
   * @type {Element}
   */

  // Data Table.
  link = document.querySelector('link[href="src/partials/listing.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  // Individual row inside data table.
  link = document.querySelector('link[href="src/partials/row.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  // Autocomplete input used in search.
  link = document.querySelector('link[href="src/partials/autocomplete-input.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  // Confirm button used for sending commands and creating sites.
  link = document.querySelector('link[href="src/partials/confirm-button.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  // Commands form.
  link = document.querySelector('link[href="src/partials/commands.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  /**
   * Vue instance for the sites page.
   *
   * @type {Vue}
   */
  let siteListing = new Vue({
    el: '#site-listing',
    data: {
      searchQuery: '',
      statsQuery: '',
      statsQueryName: '',
      statsQueryDescription: '',
      statsQueryEndpoint: '',
      statsQueryTags: '',
      optionsKey: 'statsQueryOptions',
      sitesData: [],
      statsData: [],
      codeData: [],
      cachedRecords: [],
      editKeys: ['path', 'status'],
      selectKeys: ['status'],
      callback: 'updateSiteRecord',
      reset: false,
      rowViewContent: {},
      showStatsSearch: false,
      showCommands: false,
    },
    created: function () {
      // Assign this to that in case needed in events.
      let that = this;

      bus.$on('sendCommand', function (params) {
        that.sendCommandListener(params, that);
      });

      bus.$on('switchEnv', function (env) {
        that.initialize();
      });

      // When a user tries to edit a site record, update data if etags don't match.
      bus.$on('etagFail', function (env) {
        that.etagFailListener(env, that);
      });

      bus.$on('updateSiteRecord', function (params) {
        updateSiteRecord(params);
      });

      bus.$on('deleteRecord', function (params) {
        updateSiteRecord(params, 'DELETE');
      });

      // Set anything that needs updated when in edit mode.
      bus.$on('rowEdit', function (row) {
        that.rowEditListener(row, that);
      });

      // Display whole record in view area.
      bus.$on('rowView', function (row) {
        that.rowViewListener(row, that);
      });

      // Hides record view and repopulates data table.
      bus.$on('rowHide', function (row) {
        that.rowHideListener(row, that);
      });

      // Listen for autocomplete selections and match both inputs.
      bus.$on('select', function (params) {
        that.selectListener(params, that);
      });

      // Show search when icon in navbar is clicked.
      // Also refresh table data.
      bus.$on('navbarShow', function (component) {
        that.navbarShowListener(component, that);
      });

      // Updates data table after site record data has been grabbed.
      // Currently adds code and stats records data.
      bus.$on('tableDataUpdate', function (siteRecords) {
        that.tableDataUpdateListener(siteRecords, that);
      });

      // Exports data in table when export button is clicked.
      bus.$on('exportTable', function (params) {
        that.exportTableListener(params, that);
      });

      bus.$on('createSite', function (params) {
        createSite(params);
      });
    },
    computed: {
      showReset: function () {
        return siteListing.reset;
      },
      gridColumns: function () {
        // Merge site and stats keys together.
        let siteKeys = localStorage.getItem('site-keys') ? JSON.parse(localStorage.getItem('site-keys')) : store.state.siteKeys;

        // Make stats empty if not saved since adding all of those keys makes the table unusable.
        let statsKeys = localStorage.getItem('stats-keys') ? JSON.parse(localStorage.getItem('stats-keys')) : [];

        console.log(siteKeys.concat(statsKeys));
        return siteKeys.concat(statsKeys);
      },
      gridData: function () {
        return [].concat(this.sitesData, this.statsData, this.codeData);
      }
    },
    methods: {
      initialize: function () {
        // Make sure data table is empty.
        this.sitesData = [];
        this.codeData = [];
        this.statsData = [];
        this.cachedRecords = [];

        getSiteRecords(store.state.atlasEnvironments[store.state.env])
          .then(function (data) {
            siteListing.sitesData = data;
            // Cache the result until the next request.
            siteListing.cachedRecords = data;

            // Hide any row if it was being viewed.
            siteListing.rowViewContent = {};

            // Emit event so other data can be added to the table.
            bus.$emit('tableDataUpdate', data);
          });

        // Setup commands for select list.
        getAtlasCommands();

        // Grab search queries.
        getSearchQueries();
      },
      search: function () {
        let query = null;
        let name = null;
        let that = this;

        // Grab keyword to search for.
        // The keywords are in separate unnamed autocomplete components.
        // @todo See if query and name can be stored in Store object.
        this.$children.forEach(function (element, index) {
          if (element.theKey === 'query') {
            query = element.keyword;
          }
          if (element.theKey === 'title') {
            name = element.keyword;
          }
        });

        // If no query, then emit an error message and return.
        if (query === null) {
          bus.$emit('onMessage', {
            text: 'No query found.',
            alertType: 'alert-danger'
          });
          return;
        }

        // Make request to Atlas.
        let baseURL = store.state.atlasEnvironments[store.state.env];

        atlasRequest(baseURL, 'statistics', '?where=' + query)
          .then(function (objects) {

            // If no search results returned, catch with error.
            if (typeof objects["0"]._error !== 'undefined') {
              bus.$emit('onMessage', {
                text: 'Error in Atlas Request: ' + objects["0"]._error.message + '. Your search has been reset.',
                alertType: 'alert-danger'
              });
              that.$options.methods.resetSearch(that);
            }

            // Get array only of site IDs to check from stats query.
            let siteIds = [];
            objects.forEach(function (elements, index) {
              elements.forEach(function (element, index) {
                siteIds.push(element['site']);
              });
            });

            // Filter results by using the site ID stored in stats records.
            // By setting the gridData property, the view will automatically update.
            siteListing.sitesData = siteListing.cachedRecords.filter(function (row) {
              return siteIds.indexOf(row['id']) > -1;
            });
            siteListing.reset = true;
          })
          .catch((error) => {
            console.log(error);
          });
      },
      resetSearch: function (that = null) {
        let thing = {};
        if (that) {
          thing = that;
        } else {
          thing = this;
        }

        // Reset keywords in child components.
        // @todo see if this can be stored in Store object.
        thing.$children.forEach(function (element, index) {
          if (typeof element.keyword !== 'undefined') {
            element.keyword = '';
          }
        });

        // Reset other query fields not in autocomplete component.
        this.statsQueryDescription = '';
        this.statsQueryEndpoint = '';
        this.statsQueryTags = '';

        // Reset stored query.
        store.commit('storeQuery', null);

        // By using the cached results when the page is loaded, the query can be reverted.
        siteListing.sitesData = siteListing.cachedRecords;
        siteListing.searchQuery = '';
        siteListing.reset = false;
      },
      saveSearch: function () {
        let queryToSend = null;
        let name = null;

        // Grab keyword to search for.
        this.$children.forEach(function (element, index) {
          if (element.theKey === 'query') {
            queryToSend = element.keyword;
          }
          if (element.theKey === 'title') {
            name = element.keyword;
          }
        });

        // Convert to unicode.
        queryToSend = convertToUnicode(queryToSend);

        // Make tags into string with quotes.
        const tags = this.statsQueryTags.replace(new RegExp(',', 'g'), '","');
        const data = '{"title": "' + name + '", "description": "' + this.statsQueryDescription + '", "endpoint": ["statistic"], "query": "' + queryToSend + '", "tags": ["' + tags + '"], "rank": 1}';

        // Make request to Atlas.
        let baseURL = store.state.atlasEnvironments[store.state.env];
        let currentQuery = store.state.currentQuery;

        // If there is a current query, then we assume we are patching it.
        if (currentQuery !== null) {
          atlasRequest(baseURL, 'query/' + currentQuery['_id'], '', 'PATCH', data, currentQuery['_etag'])
            .then((response) => {
              bus.$emit('onMessage', {
                text: 'You have sent a PATCH request to a query record. query ID: ' + currentQuery['_id'] + '. Search and reset to add new query.',
                alertType: 'alert-success'
              });
            })
            .catch((error) => {
              console.log(error);
            });
        } else {
          // If no current query, then we assume we are making a new one.
          atlasRequest(baseURL, 'query', '', 'POST', data)
            .then((response) => {
              bus.$emit('onMessage', {
                text: 'You have sent a POST request to add query record. Search and reset to add new query.',
                alertType: 'alert-success'
              });
            })
            .catch((error) => {
              console.log(error);
            });
        }
      },
      userAccessPerm: function (permission) {
        return userAccess(permission);
      },
      rowViewListener: function (row, that) {

        // Set temp variable for holding what was in the current table.
        // We can't used the cached data as that is a list of all the records.
        siteListing.tempGridData = siteListing.gridData;

        // Filter table to only show that record.
        that.sitesData = [row.oldData];
        that.statsData = [];
        that.codeData = [];

        // Make call to stats page to get full data to inject.
        fetch(store.state.atlasEnvironments[store.state.env] + 'statistics/' + row.data.statistics)
          .then(handleErrors)
          .then(response => response.json())
          .then(function (data) {
            siteListing.rowViewContent = data;
          })
          .catch(error => error);
      },
      sendCommandListener: function (params, that) {
        // Get site Ids to send.
        let siteIds = '"' + store.state.sitesSendCommand.join('","') + '"';
        let queryToSend = '{"path":{"$in":[' + siteIds + ']}}';

        // Convert to unicode.
        queryToSend = convertToUnicode(queryToSend);

        // Don't JSON encode since it escapes too much.
        let body = '{"query": "' + queryToSend + '"}';

        // Get command data for etag.
        let command = store.state.commands.filter(function (element, index) {
          return element._id === params.command;
        });

        atlasRequest(store.state.atlasEnvironments[store.state.env], 'commands/' + command[0]._id, query = '', 'PATCH', body, command[0]._etag);
      },
      etagFailListener: function (env, that) {
        getSiteRecords(store.state.atlasEnvironments[env])
          .then(function (data) {
            siteListing.gridData = data;
            // Cache the result until the next request.
            siteListing.cachedRecords = data;
          });
      },
      rowEditListener: function (row, that) {
        // Add special edit content to the row key by key.
        row.editKeys.forEach(function (element, index) {
          // Need to set edit row options to nothing so they can render in component.
          let options = {
            rowId: row.data.id,
            rowKey: element,
            content: ''
          };
          store.commit('addEditContent', options);
        });
      },
      rowHideListener: function (row, that) {
        // Filter table to only show that record.
        that.sitesData = siteListing.tempGridData;
        that.statsData = [];
        that.codeData = [];
        that.rowViewContent = {};
      },
      selectListener: function (params, that) {
        // Since we know that we have queries and titles, we can check the key and
        // make the opposite property match what the user selected.
        let params2 = {};
        if (params.key === 'title') {
          params2 = {
            keyword: params.selectedOption.query,
            key: 'query'
          };
          bus.$emit('matchKeys', params2);
        } else {
          params2 = {
            keyword: params.selectedOption.title,
            key: 'title'
          };
          bus.$emit('matchKeys', params2);
        }

        // Fill in other keys.
        let currentQuery = {};
        store.state.statsQueryOptions.forEach(function (element, index) {
          if (params2.key === 'title' && element.title === params2.keyword) {
            that.statsQueryDescription = element.description;
            that.statsQueryEndpoint = element.endpoint;
            that.statsQueryTags = element.tags.join(',');
            currentQuery = element;
          }

          if (params2.key === 'query' && element.query === params2.keyword) {
            that.statsQueryDescription = element.description;
            that.statsQueryEndpoint = element.endpoint;
            that.statsQueryTags = element.tags.join(',');
            currentQuery = element;
          }
        });

        // Save current query for check when updating queries.
        store.commit('storeQuery', currentQuery);
      },
      navbarShowListener: function (component, that) {
        if (component === 'statsSearch') {
          that.showStatsSearch = !that.showStatsSearch;
        }

        if (component === 'commands') {
          that.showCommands = !that.showCommands;
        }

        // Table means the data table and clicking the refresh icon.
        if (component === 'table') {
          that.initialize();
        }
      },
      tableDataUpdateListener: function (siteRecords, that) {
        // Update table with code data once site records have been loaded.
        let baseURL = store.state.atlasEnvironments[store.state.env];
        getCodeRecords(baseURL)
          .then(function (codeRecords) {
            addCodeToSites(siteRecords, codeRecords);
          })
          .catch(error => console.log(error));

        // Update with stats data.
        getStatsRecords(siteRecords, baseURL)
          .then(function (statsRecords) {
            addStatsToSites(siteRecords, statsRecords);
          })
          .catch(error => console.log(error));
      },
      exportTableListener: function (params, that) {
        let rows = store.state.filteredData;
        let columns = params.columns;
        let headers = {};

        // Filter rows to only have keys visible in table.
        let exportData = rows.map(function (item) {
          let returnItem = {};
          columns.forEach(function (element, index) {

            // Need to join arrays with different value than comma.
            if (Array.isArray(item[element])) {
              item[element] = item[element].join('|');
            }
            // If item is still an object, then we need to do more work.
            else if (typeof item[element] === "object") {
              let mrString = '';
              for (thing in item[element]) {
                mrString = mrString + '|' + thing + ':' + item[element][thing];
              }
              item[element] = mrString;
            }
            // Strings can have commas.
            else if (typeof item[element] === 'string') {
              item[element] = item[element].replace(new RegExp(',', 'g'), '|');
            }

            returnItem[element] = item[element];

            // Also make columns into header objects.
            headers[element] = element;
          });
          return returnItem;
        });

        // Export to CSV file.
        exportCSVFile(headers, exportData, 'report');
      }
    }
  });
</script>
</body>
</html>
